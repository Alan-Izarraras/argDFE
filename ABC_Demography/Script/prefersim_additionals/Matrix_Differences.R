#Takes trees generated by prefersimulation and mssel tree transformation and makes it into coalescent matrix
#Then uses coalescent matrix as summary stat for ABC posterior finding via a results file.
#This is applied to whole genome yoruba population

library(ape)

#Get demographic and ABC parameters
args <- commandArgs(trailingOnly = TRUE)
SGE_TASK_ID <- args[1]
PresentSize <- args[2]
PastSize <- args[3]

print(paste("using random number: ", SGE_TASK_ID))
print(paste("using presentSize: ", PresentSize))
print(paste("using pastSize: ", PastSize))

PresentSize <- as.numeric(PresentSize)
PastSize <- as.numeric(PastSize)

#Parameters
#Read in trees and transforms to coalescent matrix
lista_arboles <- read.tree(paste("../Data/Parameters/Output/matrices/tree_dump/trees_ABCDemography_", SGE_TASK_ID, ".txt", sep=""))
lista_intervalos <- list()
cuenta <- read.table(paste("../Data/Parameters/Output/matrices/tree_dump/trees_ABCDemography_", SGE_TASK_ID, ".txt", sep=""))

if (nrow(cuenta) == 1)  {
  ci <- coalescent.intervals(lista_arboles)
  lista_intervalos[1] <- c(ci[2])
} else  {
  for (i in 1:length(lista_arboles))  {
    ci <- coalescent.intervals(lista_arboles[[i]])
    lista_intervalos[i] <- c(ci[2])
  }
}

num.obs <- sapply(lista_intervalos, length)
seq.max <- seq_len(max(num.obs))
matriz_intervalos <- t(sapply(lista_intervalos, "[", i = seq.max))
singletones <- read.table(paste("../Data/Parameters/Output/matrices/tree_dump/singletons_", SGE_TASK_ID, "_ready.txt", sep=""))
colnames(singletones) <- c(1,2)
matriz_temp <- matrix(nrow=nrow(singletones), ncol=ncol(matriz_intervalos)-2)
matriz_temp <- cbind(singletones, matriz_temp)
colnames(matriz_temp) <- seq(1:ncol(matriz_intervalos))
colnames(matriz_intervalos) <- seq(1:ncol(matriz_intervalos))
matriz_intervalos <- rbind(matriz_temp, matriz_intervalos)

ajuste_poblacional <- 4*PresentSize
matriz_intervalos <- matriz_intervalos * (4*PresentSize)
tiempo_acumulado <- matrix(nrow=nrow(matriz_intervalos), ncol=ncol(matriz_intervalos))

for (r in 1:nrow(matriz_intervalos))  {
  i<-1
  suma <- matriz_intervalos[r,i]
  tiempo_acumulado[r,i] <- suma
  for (c in 1:ncol(matriz_intervalos))  {
    suma <- suma + matriz_intervalos[r, i+1]
    tiempo_acumulado[r, i+1] <- suma
    i <- i+1
    if (tiempo_acumulado[r,1] - tiempo_acumulado[r,2] == 0)  {
      tiempo_acumulado[r,2] = 0
    }
    if (i==ncol(matriz_intervalos))  { #Aqui el cambio 99 por ncol(matriz_intervalos)
      break
    }
  }
}

matriz_intervalos[is.na(matriz_intervalos)] <- 0
tiempo_acumulado[is.na(tiempo_acumulado)] <- 0
max_linajes <- ncol(matriz_intervalos) #Aqui otro cambio ncol(matriz_intervalos)
num_linajes <- 1

for (i in 1:nrow(tiempo_acumulado))  {
  num_linajes[i] <- match(0, tiempo_acumulado[i,])
  if (0 %in% num_linajes[i])  {
    num_linajes[i] <- max_linajes
  }
}

num_linajes[is.na(num_linajes)] <- max_linajes
rangos_tiempo <- c(0.000002, 0.000020, 0.000200, 0.002000, 0.020000, 0.200000, 2.000000, 16)
rangos_tiempo <- rangos_tiempo * 60000
matriz_linajes <- matrix(nrow=nrow(tiempo_acumulado), ncol=length(rangos_tiempo)) #24 columnas porque es la division de tiempo usada.
matriz_linajes <- matriz_linajes^0 #Requerimos que todo esté en 1s para empezar el proceso.

for (r in 1:nrow(tiempo_acumulado))  {
  num_linajes[r]
  i <- 1
  for (c in 1:ncol(tiempo_acumulado))  {
    while (tiempo_acumulado[r,c] > rangos_tiempo[i])  {
      matriz_linajes[r, i] <- num_linajes[r]
      i <- i +1
    }
    num_linajes[r] <- num_linajes[r] - 1
    matriz_linajes[r,i] <- num_linajes[r]
  }
}

#Recuerda que un singleton es cuenta 2 porque está acoplado al ancestral y un linaje cuenta 1 ya solo es el ancestral.
matriz_linajes[matriz_linajes<1] <- 1
matriz_conteo <- matrix(nrow=ncol(matriz_intervalos), ncol=length(rangos_tiempo)) # Para esto creamos matriz de conteo, con rows = num linajes y ncol = rangos de tiempo.
matriz_conteo <- matriz_conteo^0*0 #Queremos la matriz en 0s.

for (c in 1:ncol(matriz_linajes))  {
  freq_col <- as.data.frame(table(matriz_linajes[,c]))
  for (x in nrow(matriz_conteo):1)  {
    #Si el valor X se encuentra en la columna de valores, entonces pegar su freq en matriz_conteo[x,c]
    if (x %in% freq_col$Var1)  { # True si se encuentra.
      indice <- match(x, freq_col$Var1)
      fila <- (max_linajes + 1) -x
      matriz_conteo[fila, c] <- freq_col$Freq[indice] #Poner el 215 en una variable.
    }
  }
}

class(matriz_conteo[1,8])

#This is dependant on the number of samples, this was constructed for 200 genomes or 100 indvs.
filas_extra <- 199 - ncol(matriz_intervalos)
matriz_extra <- matrix(nrow = filas_extra, ncol = ncol(matriz_conteo))
matriz_extra[is.na(matriz_extra)] <- 0
matriz_conteo <- rbind(matriz_extra, matriz_conteo)

#Sitios invariables caso matriz completa
vector_1 <- vector()

l = 16634285 #Total number of synonimous sites in human genome
l = round(l / 100) #Since we are looking at probability, this operation reduces times while not distorting probability
max_sitios <- l

for (i in 1:ncol(matriz_conteo))  {
  vector_1[i] <- max_sitios - matriz_conteo[199,8] #numero maximo de arboles siempre esta en esa coordenada
}

matriz_conteo_invariables <- rbind(matriz_conteo, vector_1) #Hasta aqui tengo matriz con num de sitios invariables.
matriz_prob_invariables <- matriz_conteo_invariables / max_sitios
rownames(matriz_conteo_invariables) <- c(1:200)

#Now, rename matrices so i dont have 2 matrices.
#write.csv(matriz_conteo_invariables, paste("../Data/Parameters/Output/trees/training_matrices/matriz_conteo_invariables_full", SGE_TASK_ID, ".csv", sep=""), row.names = FALSE)
#write.csv(matriz_prob_invariables, paste("../Data/Parameters/Output/trees/training_matrices/matriz_prob_invariables_full", SGE_TASK_ID, ".csv", sep=""), row.names = FALSE)

#Hago matriz con rangos de frecuencia
matriz_conteo_rangos <- matrix(nrow= 20, ncol=length(rangos_tiempo))

for (c in 1:ncol(matriz_conteo))  {
  suma <- 0
  i <- 1
  contador = 0
  for (r in 1:nrow(matriz_conteo))  {
    contador = contador + 1
    suma <- suma + matriz_conteo[r,c]
    if (contador==10)  { #Cambiar aqui
      matriz_conteo_rangos[i,c] <- suma
      suma <- 0
      i <- i+1
      contador = 0
    }
    else  {
      matriz_conteo_rangos[i,c] <- suma
    }
  }
}

#Sitios invariables caso matriz rangos
vector_1 <- vector()

for (i in 1:ncol(matriz_conteo))  {
  vector_1[i] <- max_sitios - matriz_conteo_rangos[20,8] #numero maximo de arboles siempre esta en esa coordenada
}

matriz_conteo_invariables_rangos <- rbind(matriz_conteo_rangos, vector_1) #Hasta aqui tengo matriz con num de sitios invariables.
rownames(matriz_conteo_invariables_rangos) <- c(1:21)
matriz_prob_invariables_rangos <- matriz_conteo_invariables_rangos / max_sitios

write.csv(matriz_conteo_invariables_rangos, paste("../Data/Parameters/Output/matrices/training_matrices/matriz_conteo_", SGE_TASK_ID, ".csv", sep=""), row.names = FALSE)
write.csv(matriz_prob_invariables_rangos, paste("../Data/Parameters/Output/matrices/training_matrices/matriz_prob_", SGE_TASK_ID, ".csv", sep=""), row.names = FALSE)

#### Constructing ABC statistic file & comparison
#Data/Parameters/Output/matrices/Yoruba
stdpopsim <- read.csv("../Data/Parameters/Output/matrices/observed_matrices/matriz_prob_YorubaWGS_sinonimo.csv")
#stdpopsim <- stdpopsim[, -1]

#Version1, means distance from reference matrix, eother negative or positive.
#negative = reference is smaller, positive, reference is bigger.
Matriz_M = stdpopsim - matriz_prob_invariables_rangos

write.csv(Matriz_M, paste("../Data/Parameters/Output/matrices/training_matrices/matriz_M_", SGE_TASK_ID, ".csv", sep=""), row.names = FALSE)

Valor_M <- sum(abs(Matriz_M))
print(Valor_M)
#print("Valor de la semilla aleatoria: ", SGE_TASK_ID)

#appends M value and RandomSeed to the first line of DemographyData
# Create the new data string without a leading tab
new_data <- paste(Valor_M, SGE_TASK_ID, sep = "\t")
file_path <- paste("../Data/Parameters/DemographyData", SGE_TASK_ID,".txt", sep="")
# Read the existing line from the file
info_previa <- readLines(file_path)
# Concatenate the existing info with the new data, adding a single tab in between
info_concatenada <- paste(info_previa, new_data, sep = "\t")

# Write the concatenated string back to the file
writeLines(info_concatenada, file_path)

#Append line of DemographyData to final report file
report_file <- "../Data/Parameters/Output/DemoRun/DemographyReport.txt"
line <- readLines(file_path, n = 1)
write(line, file = report_file, append = TRUE)

#Now just test the script arguments.
